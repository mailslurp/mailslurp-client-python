<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.0">
<title>mailslurp_client.api.webhook_controller_api API documentation</title>
<meta name="description" content="MailSlurp API â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mailslurp_client.api.webhook_controller_api</code></h1>
</header>
<section id="section-intro">
<p>MailSlurp API</p>
<p>MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.
## Resources
- <a href="https://www.mailslurp.com">Homepage</a> - Get an <a href="https://app.mailslurp.com/sign-up/">API KEY</a> - Generated <a href="https://docs.mailslurp.com/">SDK Clients</a> - <a href="https://github.com/mailslurp/examples">Examples</a> repository
# noqa: E501</p>
<p>The version of the OpenAPI document: 6.5.2
Contact: contact@mailslurp.dev
Generated by: <a href="https://openapi-generator.tech">https://openapi-generator.tech</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi"><code class="flex name class">
<span>class <span class="ident">WebhookControllerApi</span></span>
<span>(</span><span>api_client=None)</span>
</code></dt>
<dd>
<div class="desc"><p>NOTE: This class is auto generated by OpenAPI Generator
Ref: <a href="https://openapi-generator.tech">https://openapi-generator.tech</a></p>
<p>Do not edit the class manually.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebhookControllerApi(object):
    &#34;&#34;&#34;NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    &#34;&#34;&#34;

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_account_webhook(self, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Attach a WebHook URL to an inbox  # noqa: E501

        Get notified of account level events such as bounce and bounce recipient.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.create_account_webhook(create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWebhookOptions create_webhook_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.create_account_webhook_with_http_info(create_webhook_options, **kwargs)  # noqa: E501

    def create_account_webhook_with_http_info(self, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Attach a WebHook URL to an inbox  # noqa: E501

        Get notified of account level events such as bounce and bounce recipient.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.create_account_webhook_with_http_info(create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateWebhookOptions create_webhook_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;create_webhook_options&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method create_account_webhook&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;create_webhook_options&#39; is set
        if self.api_client.client_side_validation and (&#39;create_webhook_options&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;create_webhook_options&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `create_webhook_options` when calling `create_account_webhook`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;create_webhook_options&#39; in local_var_params:
            body_params = local_var_params[&#39;create_webhook_options&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def create_webhook(self, inbox_id, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Attach a WebHook URL to an inbox  # noqa: E501

        Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.create_webhook(inbox_id, create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param CreateWebhookOptions create_webhook_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.create_webhook_with_http_info(inbox_id, create_webhook_options, **kwargs)  # noqa: E501

    def create_webhook_with_http_info(self, inbox_id, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Attach a WebHook URL to an inbox  # noqa: E501

        Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.create_webhook_with_http_info(inbox_id, create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param CreateWebhookOptions create_webhook_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;inbox_id&#39;,
            &#39;create_webhook_options&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method create_webhook&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;inbox_id&#39; is set
        if self.api_client.client_side_validation and (&#39;inbox_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;inbox_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `inbox_id` when calling `create_webhook`&#34;)  # noqa: E501
        # verify the required parameter &#39;create_webhook_options&#39; is set
        if self.api_client.client_side_validation and (&#39;create_webhook_options&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;create_webhook_options&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `create_webhook_options` when calling `create_webhook`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;inbox_id&#39; in local_var_params:
            path_params[&#39;inboxId&#39;] = local_var_params[&#39;inbox_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;create_webhook_options&#39; in local_var_params:
            body_params = local_var_params[&#39;create_webhook_options&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/inboxes/{inboxId}/webhooks&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def create_webhook_for_phone_number(self, phone_number_id, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Attach a WebHook URL to a phone number  # noqa: E501

        Get notified whenever a phone number receives an SMS via a WebHook URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.create_webhook_for_phone_number(phone_number_id, create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str phone_number_id: (required)
        :param CreateWebhookOptions create_webhook_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.create_webhook_for_phone_number_with_http_info(phone_number_id, create_webhook_options, **kwargs)  # noqa: E501

    def create_webhook_for_phone_number_with_http_info(self, phone_number_id, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Attach a WebHook URL to a phone number  # noqa: E501

        Get notified whenever a phone number receives an SMS via a WebHook URL.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.create_webhook_for_phone_number_with_http_info(phone_number_id, create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str phone_number_id: (required)
        :param CreateWebhookOptions create_webhook_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;phone_number_id&#39;,
            &#39;create_webhook_options&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method create_webhook_for_phone_number&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;phone_number_id&#39; is set
        if self.api_client.client_side_validation and (&#39;phone_number_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;phone_number_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `phone_number_id` when calling `create_webhook_for_phone_number`&#34;)  # noqa: E501
        # verify the required parameter &#39;create_webhook_options&#39; is set
        if self.api_client.client_side_validation and (&#39;create_webhook_options&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;create_webhook_options&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `create_webhook_options` when calling `create_webhook_for_phone_number`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;phone_number_id&#39; in local_var_params:
            path_params[&#39;phoneNumberId&#39;] = local_var_params[&#39;phone_number_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;create_webhook_options&#39; in local_var_params:
            body_params = local_var_params[&#39;create_webhook_options&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/phone/numbers/{phoneNumberId}/webhooks&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def delete_all_webhooks(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Delete all webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_all_webhooks(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime before: before
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.delete_all_webhooks_with_http_info(**kwargs)  # noqa: E501

    def delete_all_webhooks_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Delete all webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_all_webhooks_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime before: before
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;before&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method delete_all_webhooks&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks&#39;, &#39;DELETE&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def delete_webhook(self, inbox_id, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Delete and disable a Webhook for an Inbox  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_webhook(inbox_id, webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param str webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.delete_webhook_with_http_info(inbox_id, webhook_id, **kwargs)  # noqa: E501

    def delete_webhook_with_http_info(self, inbox_id, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Delete and disable a Webhook for an Inbox  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_webhook_with_http_info(inbox_id, webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param str webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;inbox_id&#39;,
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method delete_webhook&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;inbox_id&#39; is set
        if self.api_client.client_side_validation and (&#39;inbox_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;inbox_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `inbox_id` when calling `delete_webhook`&#34;)  # noqa: E501
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `delete_webhook`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;inbox_id&#39; in local_var_params:
            path_params[&#39;inboxId&#39;] = local_var_params[&#39;inbox_id&#39;]  # noqa: E501
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/inboxes/{inboxId}/webhooks/{webhookId}&#39;, &#39;DELETE&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def delete_webhook_by_id(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Delete a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_webhook_by_id(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.delete_webhook_by_id_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def delete_webhook_by_id_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Delete a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.delete_webhook_by_id_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method delete_webhook_by_id&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `delete_webhook_by_id`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}&#39;, &#39;DELETE&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_all_account_webhooks(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;List account webhooks Paginated  # noqa: E501

        List account webhooks in paginated form. Allows for page index, page size, and sort direction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_account_webhooks(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size for paginated result list.
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param str event_type: Optional event type
        :param str health: Filter by webhook health
        :param str search_filter: Optional search filter
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookProjection
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_all_account_webhooks_with_http_info(**kwargs)  # noqa: E501

    def get_all_account_webhooks_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;List account webhooks Paginated  # noqa: E501

        List account webhooks in paginated form. Allows for page index, page size, and sort direction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_account_webhooks_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size for paginated result list.
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param str event_type: Optional event type
        :param str health: Filter by webhook health
        :param str search_filter: Optional search filter
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;since&#39;,
            &#39;before&#39;,
            &#39;event_type&#39;,
            &#39;health&#39;,
            &#39;search_filter&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_all_account_webhooks&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        if self.api_client.client_side_validation and &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] &gt; 9223372036854775807:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `page` when calling `get_all_account_webhooks`, must be a value less than or equal to `9223372036854775807`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] &lt; 0:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `page` when calling `get_all_account_webhooks`, must be a value greater than or equal to `0`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] &gt; 100:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `size` when calling `get_all_account_webhooks`, must be a value less than or equal to `100`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] &lt; 1:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `size` when calling `get_all_account_webhooks`, must be a value greater than or equal to `1`&#34;)  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;event_type&#39; in local_var_params and local_var_params[&#39;event_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventType&#39;, local_var_params[&#39;event_type&#39;]))  # noqa: E501
        if &#39;health&#39; in local_var_params and local_var_params[&#39;health&#39;] is not None:  # noqa: E501
            query_params.append((&#39;health&#39;, local_var_params[&#39;health&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/account/paginated&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookProjection&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_all_webhook_endpoints(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;List Webhooks endpoints Paginated  # noqa: E501

        List webhooks URL in paginated form. Allows for page index, page size, and sort direction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_webhook_endpoints(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size for paginated result list.
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param str inbox_id: Filter by inboxId
        :param str phone_id: Filter by phoneId
        :param datetime before: Filter by created at before the given timestamp
        :param str health: Filter by webhook health
        :param str event_type: Optional event type
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookEndpointProjection
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_all_webhook_endpoints_with_http_info(**kwargs)  # noqa: E501

    def get_all_webhook_endpoints_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;List Webhooks endpoints Paginated  # noqa: E501

        List webhooks URL in paginated form. Allows for page index, page size, and sort direction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_webhook_endpoints_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size for paginated result list.
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param str inbox_id: Filter by inboxId
        :param str phone_id: Filter by phoneId
        :param datetime before: Filter by created at before the given timestamp
        :param str health: Filter by webhook health
        :param str event_type: Optional event type
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookEndpointProjection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;search_filter&#39;,
            &#39;since&#39;,
            &#39;inbox_id&#39;,
            &#39;phone_id&#39;,
            &#39;before&#39;,
            &#39;health&#39;,
            &#39;event_type&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_all_webhook_endpoints&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        if self.api_client.client_side_validation and &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] &gt; 9223372036854775807:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `page` when calling `get_all_webhook_endpoints`, must be a value less than or equal to `9223372036854775807`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] &lt; 0:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `page` when calling `get_all_webhook_endpoints`, must be a value greater than or equal to `0`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] &gt; 100:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `size` when calling `get_all_webhook_endpoints`, must be a value less than or equal to `100`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] &lt; 1:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `size` when calling `get_all_webhook_endpoints`, must be a value greater than or equal to `1`&#34;)  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;inbox_id&#39; in local_var_params and local_var_params[&#39;inbox_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;inboxId&#39;, local_var_params[&#39;inbox_id&#39;]))  # noqa: E501
        if &#39;phone_id&#39; in local_var_params and local_var_params[&#39;phone_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;phoneId&#39;, local_var_params[&#39;phone_id&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;health&#39; in local_var_params and local_var_params[&#39;health&#39;] is not None:  # noqa: E501
            query_params.append((&#39;health&#39;, local_var_params[&#39;health&#39;]))  # noqa: E501
        if &#39;event_type&#39; in local_var_params and local_var_params[&#39;event_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventType&#39;, local_var_params[&#39;event_type&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/endpoints&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookEndpointProjection&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_all_webhook_results(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get results for all webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_webhook_results(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param bool unseen_only: Filter for unseen exceptions only
        :param str result_type: Filter by result type
        :param str event_name: Filter by event name
        :param int min_status_code: Minimum response status
        :param int max_status_code: Maximum response status
        :param str inbox_id: Inbox ID
        :param str sms_id: Sms ID
        :param str attachment_id: Attachment ID
        :param str email_id: Email ID
        :param str phone_id: Phone ID
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookResult
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_all_webhook_results_with_http_info(**kwargs)  # noqa: E501

    def get_all_webhook_results_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get results for all webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_webhook_results_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param bool unseen_only: Filter for unseen exceptions only
        :param str result_type: Filter by result type
        :param str event_name: Filter by event name
        :param int min_status_code: Minimum response status
        :param int max_status_code: Maximum response status
        :param str inbox_id: Inbox ID
        :param str sms_id: Sms ID
        :param str attachment_id: Attachment ID
        :param str email_id: Email ID
        :param str phone_id: Phone ID
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;search_filter&#39;,
            &#39;since&#39;,
            &#39;before&#39;,
            &#39;unseen_only&#39;,
            &#39;result_type&#39;,
            &#39;event_name&#39;,
            &#39;min_status_code&#39;,
            &#39;max_status_code&#39;,
            &#39;inbox_id&#39;,
            &#39;sms_id&#39;,
            &#39;attachment_id&#39;,
            &#39;email_id&#39;,
            &#39;phone_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_all_webhook_results&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;unseen_only&#39; in local_var_params and local_var_params[&#39;unseen_only&#39;] is not None:  # noqa: E501
            query_params.append((&#39;unseenOnly&#39;, local_var_params[&#39;unseen_only&#39;]))  # noqa: E501
        if &#39;result_type&#39; in local_var_params and local_var_params[&#39;result_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;resultType&#39;, local_var_params[&#39;result_type&#39;]))  # noqa: E501
        if &#39;event_name&#39; in local_var_params and local_var_params[&#39;event_name&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventName&#39;, local_var_params[&#39;event_name&#39;]))  # noqa: E501
        if &#39;min_status_code&#39; in local_var_params and local_var_params[&#39;min_status_code&#39;] is not None:  # noqa: E501
            query_params.append((&#39;minStatusCode&#39;, local_var_params[&#39;min_status_code&#39;]))  # noqa: E501
        if &#39;max_status_code&#39; in local_var_params and local_var_params[&#39;max_status_code&#39;] is not None:  # noqa: E501
            query_params.append((&#39;maxStatusCode&#39;, local_var_params[&#39;max_status_code&#39;]))  # noqa: E501
        if &#39;inbox_id&#39; in local_var_params and local_var_params[&#39;inbox_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;inboxId&#39;, local_var_params[&#39;inbox_id&#39;]))  # noqa: E501
        if &#39;sms_id&#39; in local_var_params and local_var_params[&#39;sms_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;smsId&#39;, local_var_params[&#39;sms_id&#39;]))  # noqa: E501
        if &#39;attachment_id&#39; in local_var_params and local_var_params[&#39;attachment_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;attachmentId&#39;, local_var_params[&#39;attachment_id&#39;]))  # noqa: E501
        if &#39;email_id&#39; in local_var_params and local_var_params[&#39;email_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;emailId&#39;, local_var_params[&#39;email_id&#39;]))  # noqa: E501
        if &#39;phone_id&#39; in local_var_params and local_var_params[&#39;phone_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;phoneId&#39;, local_var_params[&#39;phone_id&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/results&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookResult&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_all_webhooks(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;List Webhooks Paginated  # noqa: E501

        List webhooks in paginated form. Allows for page index, page size, and sort direction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_webhooks(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size for paginated result list.
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param str inbox_id: Filter by inboxId
        :param str phone_id: Filter by phoneId
        :param datetime before: Filter by created at before the given timestamp
        :param str health: Filter by webhook health
        :param str event_type: Optional event type
        :param str url: Optional url endpoint filter
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookProjection
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_all_webhooks_with_http_info(**kwargs)  # noqa: E501

    def get_all_webhooks_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;List Webhooks Paginated  # noqa: E501

        List webhooks in paginated form. Allows for page index, page size, and sort direction.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_all_webhooks_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page: Optional page index in list pagination
        :param int size: Optional page size for paginated result list.
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param str inbox_id: Filter by inboxId
        :param str phone_id: Filter by phoneId
        :param datetime before: Filter by created at before the given timestamp
        :param str health: Filter by webhook health
        :param str event_type: Optional event type
        :param str url: Optional url endpoint filter
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;search_filter&#39;,
            &#39;since&#39;,
            &#39;inbox_id&#39;,
            &#39;phone_id&#39;,
            &#39;before&#39;,
            &#39;health&#39;,
            &#39;event_type&#39;,
            &#39;url&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_all_webhooks&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        if self.api_client.client_side_validation and &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] &gt; 9223372036854775807:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `page` when calling `get_all_webhooks`, must be a value less than or equal to `9223372036854775807`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] &lt; 0:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `page` when calling `get_all_webhooks`, must be a value greater than or equal to `0`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] &gt; 100:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `size` when calling `get_all_webhooks`, must be a value less than or equal to `100`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] &lt; 1:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `size` when calling `get_all_webhooks`, must be a value greater than or equal to `1`&#34;)  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;inbox_id&#39; in local_var_params and local_var_params[&#39;inbox_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;inboxId&#39;, local_var_params[&#39;inbox_id&#39;]))  # noqa: E501
        if &#39;phone_id&#39; in local_var_params and local_var_params[&#39;phone_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;phoneId&#39;, local_var_params[&#39;phone_id&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;health&#39; in local_var_params and local_var_params[&#39;health&#39;] is not None:  # noqa: E501
            query_params.append((&#39;health&#39;, local_var_params[&#39;health&#39;]))  # noqa: E501
        if &#39;event_type&#39; in local_var_params and local_var_params[&#39;event_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventType&#39;, local_var_params[&#39;event_type&#39;]))  # noqa: E501
        if &#39;url&#39; in local_var_params and local_var_params[&#39;url&#39;] is not None:  # noqa: E501
            query_params.append((&#39;url&#39;, local_var_params[&#39;url&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/paginated&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookProjection&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_inbox_webhooks_paginated(self, inbox_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get paginated webhooks for an Inbox  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_inbox_webhooks_paginated(inbox_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param str health: Filter by webhook health
        :param str event_type: Optional event type
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookProjection
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_inbox_webhooks_paginated_with_http_info(inbox_id, **kwargs)  # noqa: E501

    def get_inbox_webhooks_paginated_with_http_info(self, inbox_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get paginated webhooks for an Inbox  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_inbox_webhooks_paginated_with_http_info(inbox_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param str health: Filter by webhook health
        :param str event_type: Optional event type
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;inbox_id&#39;,
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;search_filter&#39;,
            &#39;since&#39;,
            &#39;before&#39;,
            &#39;health&#39;,
            &#39;event_type&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_inbox_webhooks_paginated&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;inbox_id&#39; is set
        if self.api_client.client_side_validation and (&#39;inbox_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;inbox_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `inbox_id` when calling `get_inbox_webhooks_paginated`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;inbox_id&#39; in local_var_params:
            path_params[&#39;inboxId&#39;] = local_var_params[&#39;inbox_id&#39;]  # noqa: E501

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;health&#39; in local_var_params and local_var_params[&#39;health&#39;] is not None:  # noqa: E501
            query_params.append((&#39;health&#39;, local_var_params[&#39;health&#39;]))  # noqa: E501
        if &#39;event_type&#39; in local_var_params and local_var_params[&#39;event_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventType&#39;, local_var_params[&#39;event_type&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/inboxes/{inboxId}/webhooks/paginated&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookProjection&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_json_schema_for_webhook_event(self, event, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_json_schema_for_webhook_event  # noqa: E501

        Get JSON Schema definition for webhook payload by event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_json_schema_for_webhook_event(event, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JSONSchemaDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_json_schema_for_webhook_event_with_http_info(event, **kwargs)  # noqa: E501

    def get_json_schema_for_webhook_event_with_http_info(self, event, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_json_schema_for_webhook_event  # noqa: E501

        Get JSON Schema definition for webhook payload by event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_json_schema_for_webhook_event_with_http_info(event, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JSONSchemaDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;event&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_json_schema_for_webhook_event&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;event&#39; is set
        if self.api_client.client_side_validation and (&#39;event&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;event&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `event` when calling `get_json_schema_for_webhook_event`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;event&#39; in local_var_params and local_var_params[&#39;event&#39;] is not None:  # noqa: E501
            query_params.append((&#39;event&#39;, local_var_params[&#39;event&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/schema&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;JSONSchemaDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_json_schema_for_webhook_payload(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_json_schema_for_webhook_payload  # noqa: E501

        Get JSON Schema definition for webhook payload  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_json_schema_for_webhook_payload(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JSONSchemaDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_json_schema_for_webhook_payload_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def get_json_schema_for_webhook_payload_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_json_schema_for_webhook_payload  # noqa: E501

        Get JSON Schema definition for webhook payload  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_json_schema_for_webhook_payload_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JSONSchemaDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_json_schema_for_webhook_payload&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `get_json_schema_for_webhook_payload`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/schema&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;JSONSchemaDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_phone_number_webhooks_paginated(self, phone_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get paginated webhooks for a phone number  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_phone_number_webhooks_paginated(phone_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str phone_id: (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param str event_type: Optional event type
        :param str search_filter: Optional search filter
        :param str health: Filter by webhook health
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookProjection
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_phone_number_webhooks_paginated_with_http_info(phone_id, **kwargs)  # noqa: E501

    def get_phone_number_webhooks_paginated_with_http_info(self, phone_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get paginated webhooks for a phone number  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_phone_number_webhooks_paginated_with_http_info(phone_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str phone_id: (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param str event_type: Optional event type
        :param str search_filter: Optional search filter
        :param str health: Filter by webhook health
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;phone_id&#39;,
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;since&#39;,
            &#39;before&#39;,
            &#39;event_type&#39;,
            &#39;search_filter&#39;,
            &#39;health&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_phone_number_webhooks_paginated&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;phone_id&#39; is set
        if self.api_client.client_side_validation and (&#39;phone_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;phone_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `phone_id` when calling `get_phone_number_webhooks_paginated`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;phone_id&#39; in local_var_params:
            path_params[&#39;phoneId&#39;] = local_var_params[&#39;phone_id&#39;]  # noqa: E501

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;event_type&#39; in local_var_params and local_var_params[&#39;event_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventType&#39;, local_var_params[&#39;event_type&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501
        if &#39;health&#39; in local_var_params and local_var_params[&#39;health&#39;] is not None:  # noqa: E501
            query_params.append((&#39;health&#39;, local_var_params[&#39;health&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/phone/numbers/{phoneId}/webhooks/paginated&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookProjection&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload  # noqa: E501

        Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AbstractWebhookPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload  # noqa: E501

        Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str event_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AbstractWebhookPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;event_name&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []
        if &#39;event_name&#39; in local_var_params and local_var_params[&#39;event_name&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventName&#39;, local_var_params[&#39;event_name&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;AbstractWebhookPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_bounce(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_bounce  # noqa: E501

        Get webhook test payload for bounce  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookBouncePayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_bounce_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_bounce_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_bounce  # noqa: E501

        Get webhook test payload for bounce  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookBouncePayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_bounce&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/email-bounce-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookBouncePayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_bounce_recipient(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_bounce_recipient  # noqa: E501

        Get webhook test payload for bounce recipient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce_recipient(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookBounceRecipientPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_bounce_recipient_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_bounce_recipient_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_bounce_recipient  # noqa: E501

        Get webhook test payload for bounce recipient  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce_recipient_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookBounceRecipientPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_bounce_recipient&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/email-bounce-recipient-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookBounceRecipientPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_delivery_status(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for delivery status event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_delivery_status(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDeliveryStatusPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_delivery_status_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_delivery_status_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for delivery status event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_delivery_status_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDeliveryStatusPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_delivery_status&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/delivery-status-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDeliveryStatusPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_email_opened(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_email_opened  # noqa: E501

        Get webhook test payload for email opened event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_email_opened(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookEmailOpenedPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_email_opened_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_email_opened_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_email_opened  # noqa: E501

        Get webhook test payload for email opened event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_email_opened_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookEmailOpenedPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_email_opened&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/email-opened-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookEmailOpenedPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_email_read(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_email_read  # noqa: E501

        Get webhook test payload for email opened event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_email_read(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookEmailReadPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_email_read_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_email_read_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_email_read  # noqa: E501

        Get webhook test payload for email opened event  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_email_read_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookEmailReadPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_email_read&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/email-read-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookEmailReadPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_for_webhook(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_for_webhook  # noqa: E501

        Get example payload for webhook  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_for_webhook(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AbstractWebhookPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_for_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def get_test_webhook_payload_for_webhook_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;get_test_webhook_payload_for_webhook  # noqa: E501

        Get example payload for webhook  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_for_webhook_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AbstractWebhookPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_for_webhook&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `get_test_webhook_payload_for_webhook`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/example&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;AbstractWebhookPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_new_ai_transform_result(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new ai transform result event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_ai_transform_result(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookNewAITransformResultPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_new_ai_transform_result_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_new_ai_transform_result_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new ai transform result event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_ai_transform_result_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookNewAITransformResultPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_new_ai_transform_result&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/new-ai-transform-result-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookNewAITransformResultPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_new_attachment(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new attachment event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_attachment(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookNewAttachmentPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_new_attachment_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_new_attachment_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new attachment event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_attachment_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookNewAttachmentPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_new_attachment&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/new-attachment-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookNewAttachmentPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_new_contact(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new contact event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_contact(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookNewContactPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_new_contact_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_new_contact_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new contact event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_contact_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookNewContactPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_new_contact&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/new-contact-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookNewContactPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_new_email(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new email event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_email(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookNewEmailPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_new_email_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_new_email_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new email event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_email_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookNewEmailPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_new_email&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/new-email-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookNewEmailPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_test_webhook_payload_new_sms(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new sms event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_sms(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookNewSmsPayload
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_test_webhook_payload_new_sms_with_http_info(**kwargs)  # noqa: E501

    def get_test_webhook_payload_new_sms_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get webhook test payload for new sms event  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_test_webhook_payload_new_sms_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookNewSmsPayload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_test_webhook_payload_new_sms&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/test/new-sms-payload&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookNewSmsPayload&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_webhook(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def get_webhook_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_webhook&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `get_webhook`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_webhook_result(self, webhook_result_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook result for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_result(webhook_result_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_result_id: Webhook Result ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookResultDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_webhook_result_with_http_info(webhook_result_id, **kwargs)  # noqa: E501

    def get_webhook_result_with_http_info(self, webhook_result_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook result for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_result_with_http_info(webhook_result_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_result_id: Webhook Result ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookResultDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_result_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_webhook_result&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_result_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_result_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_result_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_result_id` when calling `get_webhook_result`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_result_id&#39; in local_var_params:
            path_params[&#39;webhookResultId&#39;] = local_var_params[&#39;webhook_result_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/results/{webhookResultId}&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookResultDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_webhook_results(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook results for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_results(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: ID of webhook to get results for (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param bool unseen_only: Filter for unseen exceptions only
        :param str result_type: Filter by result type
        :param str event_name: Filter by event name
        :param int min_status_code: Minimum response status
        :param int max_status_code: Maximum response status
        :param str inbox_id: Inbox ID
        :param str sms_id: Sms ID
        :param str attachment_id: Attachment ID
        :param str email_id: Email ID
        :param str phone_id: Phone ID
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PageWebhookResult
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_webhook_results_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def get_webhook_results_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook results for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_results_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: ID of webhook to get results for (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param str search_filter: Optional search filter
        :param datetime since: Filter by created at after the given timestamp
        :param datetime before: Filter by created at before the given timestamp
        :param bool unseen_only: Filter for unseen exceptions only
        :param str result_type: Filter by result type
        :param str event_name: Filter by event name
        :param int min_status_code: Minimum response status
        :param int max_status_code: Maximum response status
        :param str inbox_id: Inbox ID
        :param str sms_id: Sms ID
        :param str attachment_id: Attachment ID
        :param str email_id: Email ID
        :param str phone_id: Phone ID
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PageWebhookResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;,
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;,
            &#39;search_filter&#39;,
            &#39;since&#39;,
            &#39;before&#39;,
            &#39;unseen_only&#39;,
            &#39;result_type&#39;,
            &#39;event_name&#39;,
            &#39;min_status_code&#39;,
            &#39;max_status_code&#39;,
            &#39;inbox_id&#39;,
            &#39;sms_id&#39;,
            &#39;attachment_id&#39;,
            &#39;email_id&#39;,
            &#39;phone_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_webhook_results&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `get_webhook_results`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501
        if &#39;search_filter&#39; in local_var_params and local_var_params[&#39;search_filter&#39;] is not None:  # noqa: E501
            query_params.append((&#39;searchFilter&#39;, local_var_params[&#39;search_filter&#39;]))  # noqa: E501
        if &#39;since&#39; in local_var_params and local_var_params[&#39;since&#39;] is not None:  # noqa: E501
            query_params.append((&#39;since&#39;, local_var_params[&#39;since&#39;]))  # noqa: E501
        if &#39;before&#39; in local_var_params and local_var_params[&#39;before&#39;] is not None:  # noqa: E501
            query_params.append((&#39;before&#39;, local_var_params[&#39;before&#39;]))  # noqa: E501
        if &#39;unseen_only&#39; in local_var_params and local_var_params[&#39;unseen_only&#39;] is not None:  # noqa: E501
            query_params.append((&#39;unseenOnly&#39;, local_var_params[&#39;unseen_only&#39;]))  # noqa: E501
        if &#39;result_type&#39; in local_var_params and local_var_params[&#39;result_type&#39;] is not None:  # noqa: E501
            query_params.append((&#39;resultType&#39;, local_var_params[&#39;result_type&#39;]))  # noqa: E501
        if &#39;event_name&#39; in local_var_params and local_var_params[&#39;event_name&#39;] is not None:  # noqa: E501
            query_params.append((&#39;eventName&#39;, local_var_params[&#39;event_name&#39;]))  # noqa: E501
        if &#39;min_status_code&#39; in local_var_params and local_var_params[&#39;min_status_code&#39;] is not None:  # noqa: E501
            query_params.append((&#39;minStatusCode&#39;, local_var_params[&#39;min_status_code&#39;]))  # noqa: E501
        if &#39;max_status_code&#39; in local_var_params and local_var_params[&#39;max_status_code&#39;] is not None:  # noqa: E501
            query_params.append((&#39;maxStatusCode&#39;, local_var_params[&#39;max_status_code&#39;]))  # noqa: E501
        if &#39;inbox_id&#39; in local_var_params and local_var_params[&#39;inbox_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;inboxId&#39;, local_var_params[&#39;inbox_id&#39;]))  # noqa: E501
        if &#39;sms_id&#39; in local_var_params and local_var_params[&#39;sms_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;smsId&#39;, local_var_params[&#39;sms_id&#39;]))  # noqa: E501
        if &#39;attachment_id&#39; in local_var_params and local_var_params[&#39;attachment_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;attachmentId&#39;, local_var_params[&#39;attachment_id&#39;]))  # noqa: E501
        if &#39;email_id&#39; in local_var_params and local_var_params[&#39;email_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;emailId&#39;, local_var_params[&#39;email_id&#39;]))  # noqa: E501
        if &#39;phone_id&#39; in local_var_params and local_var_params[&#39;phone_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;phoneId&#39;, local_var_params[&#39;phone_id&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/results&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;PageWebhookResult&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_webhook_results_count(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook results count for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_results_count(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: ID of webhook to get results for (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CountDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_webhook_results_count_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def get_webhook_results_count_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook results count for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_results_count_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: ID of webhook to get results for (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CountDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_webhook_results_count&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `get_webhook_results_count`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/results/count&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;CountDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_webhook_results_unseen_error_count(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get count of unseen webhook results with error status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_results_unseen_error_count(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: UnseenErrorCountDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_webhook_results_unseen_error_count_with_http_info(**kwargs)  # noqa: E501

    def get_webhook_results_unseen_error_count_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get count of unseen webhook results with error status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhook_results_unseen_error_count_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(UnseenErrorCountDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_webhook_results_unseen_error_count&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/results/unseen-count&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;UnseenErrorCountDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def get_webhooks(self, inbox_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get all webhooks for an Inbox  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhooks(inbox_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[WebhookProjection]
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.get_webhooks_with_http_info(inbox_id, **kwargs)  # noqa: E501

    def get_webhooks_with_http_info(self, inbox_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get all webhooks for an Inbox  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.get_webhooks_with_http_info(inbox_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str inbox_id: (required)
        :param int page: Optional page index in list pagination
        :param int size: Optional page size in list pagination
        :param str sort: Optional createdAt sort direction ASC or DESC
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[WebhookProjection], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;inbox_id&#39;,
            &#39;page&#39;,
            &#39;size&#39;,
            &#39;sort&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method get_webhooks&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;inbox_id&#39; is set
        if self.api_client.client_side_validation and (&#39;inbox_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;inbox_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `inbox_id` when calling `get_webhooks`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;inbox_id&#39; in local_var_params:
            path_params[&#39;inboxId&#39;] = local_var_params[&#39;inbox_id&#39;]  # noqa: E501

        query_params = []
        if &#39;page&#39; in local_var_params and local_var_params[&#39;page&#39;] is not None:  # noqa: E501
            query_params.append((&#39;page&#39;, local_var_params[&#39;page&#39;]))  # noqa: E501
        if &#39;size&#39; in local_var_params and local_var_params[&#39;size&#39;] is not None:  # noqa: E501
            query_params.append((&#39;size&#39;, local_var_params[&#39;size&#39;]))  # noqa: E501
        if &#39;sort&#39; in local_var_params and local_var_params[&#39;sort&#39;] is not None:  # noqa: E501
            query_params.append((&#39;sort&#39;, local_var_params[&#39;sort&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/inboxes/{inboxId}/webhooks&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;list[WebhookProjection]&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def redrive_all_webhook_results(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Redrive all webhook results that have failed status  # noqa: E501

        Allows you to resend webhook payloads for any recorded webhook result that failed to deliver the payload.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.redrive_all_webhook_results(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookRedriveAllResult
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.redrive_all_webhook_results_with_http_info(**kwargs)  # noqa: E501

    def redrive_all_webhook_results_with_http_info(self, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Redrive all webhook results that have failed status  # noqa: E501

        Allows you to resend webhook payloads for any recorded webhook result that failed to deliver the payload.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.redrive_all_webhook_results_with_http_info(async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookRedriveAllResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method redrive_all_webhook_results&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/results/redrive&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookRedriveAllResult&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def redrive_webhook_result(self, webhook_result_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook result and try to resend the original webhook payload  # noqa: E501

        Allows you to resend a webhook payload that was already sent. Webhooks that fail are retried automatically for 24 hours and then put in a dead letter queue. You can retry results manually using this method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.redrive_webhook_result(webhook_result_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_result_id: Webhook Result ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookRedriveResult
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.redrive_webhook_result_with_http_info(webhook_result_id, **kwargs)  # noqa: E501

    def redrive_webhook_result_with_http_info(self, webhook_result_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Get a webhook result and try to resend the original webhook payload  # noqa: E501

        Allows you to resend a webhook payload that was already sent. Webhooks that fail are retried automatically for 24 hours and then put in a dead letter queue. You can retry results manually using this method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.redrive_webhook_result_with_http_info(webhook_result_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_result_id: Webhook Result ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookRedriveResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_result_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method redrive_webhook_result&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_result_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_result_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_result_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_result_id` when calling `redrive_webhook_result`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_result_id&#39; in local_var_params:
            path_params[&#39;webhookResultId&#39;] = local_var_params[&#39;webhook_result_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/results/{webhookResultId}/redrive&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookRedriveResult&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def send_test_data(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Send webhook test data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.send_test_data(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookTestResult
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.send_test_data_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def send_test_data_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Send webhook test data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.send_test_data_with_http_info(webhook_id, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookTestResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method send_test_data&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `send_test_data`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/test&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookTestResult&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def update_webhook(self, webhook_id, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Update a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.update_webhook(webhook_id, create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param CreateWebhookOptions create_webhook_options: (required)
        :param str inbox_id:
        :param str phone_number_id:
        :param bool override_auth:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.update_webhook_with_http_info(webhook_id, create_webhook_options, **kwargs)  # noqa: E501

    def update_webhook_with_http_info(self, webhook_id, create_webhook_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Update a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.update_webhook_with_http_info(webhook_id, create_webhook_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param CreateWebhookOptions create_webhook_options: (required)
        :param str inbox_id:
        :param str phone_number_id:
        :param bool override_auth:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;,
            &#39;create_webhook_options&#39;,
            &#39;inbox_id&#39;,
            &#39;phone_number_id&#39;,
            &#39;override_auth&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method update_webhook&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `update_webhook`&#34;)  # noqa: E501
        # verify the required parameter &#39;create_webhook_options&#39; is set
        if self.api_client.client_side_validation and (&#39;create_webhook_options&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;create_webhook_options&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `create_webhook_options` when calling `update_webhook`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []
        if &#39;inbox_id&#39; in local_var_params and local_var_params[&#39;inbox_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;inboxId&#39;, local_var_params[&#39;inbox_id&#39;]))  # noqa: E501
        if &#39;phone_number_id&#39; in local_var_params and local_var_params[&#39;phone_number_id&#39;] is not None:  # noqa: E501
            query_params.append((&#39;phoneNumberId&#39;, local_var_params[&#39;phone_number_id&#39;]))  # noqa: E501
        if &#39;override_auth&#39; in local_var_params and local_var_params[&#39;override_auth&#39;] is not None:  # noqa: E501
            query_params.append((&#39;overrideAuth&#39;, local_var_params[&#39;override_auth&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;create_webhook_options&#39; in local_var_params:
            body_params = local_var_params[&#39;create_webhook_options&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}&#39;, &#39;PATCH&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def update_webhook_headers(self, webhook_id, webhook_headers, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Update a webhook request headers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.update_webhook_headers(webhook_id, webhook_headers, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param WebhookHeaders webhook_headers: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: WebhookDto
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.update_webhook_headers_with_http_info(webhook_id, webhook_headers, **kwargs)  # noqa: E501

    def update_webhook_headers_with_http_info(self, webhook_id, webhook_headers, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Update a webhook request headers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.update_webhook_headers_with_http_info(webhook_id, webhook_headers, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: (required)
        :param WebhookHeaders webhook_headers: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;,
            &#39;webhook_headers&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method update_webhook_headers&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `update_webhook_headers`&#34;)  # noqa: E501
        # verify the required parameter &#39;webhook_headers&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_headers&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_headers&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_headers` when calling `update_webhook_headers`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;webhook_headers&#39; in local_var_params:
            body_params = local_var_params[&#39;webhook_headers&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/headers&#39;, &#39;PUT&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;WebhookDto&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def verify_webhook_signature(self, verify_webhook_signature_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Verify a webhook payload signature  # noqa: E501

        Verify a webhook payload using the messageId and signature. This allows you to be sure that MailSlurp sent the payload and not another server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.verify_webhook_signature(verify_webhook_signature_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param VerifyWebhookSignatureOptions verify_webhook_signature_options: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VerifyWebhookSignatureResults
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.verify_webhook_signature_with_http_info(verify_webhook_signature_options, **kwargs)  # noqa: E501

    def verify_webhook_signature_with_http_info(self, verify_webhook_signature_options, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Verify a webhook payload signature  # noqa: E501

        Verify a webhook payload using the messageId and signature. This allows you to be sure that MailSlurp sent the payload and not another server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.verify_webhook_signature_with_http_info(verify_webhook_signature_options, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param VerifyWebhookSignatureOptions verify_webhook_signature_options: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VerifyWebhookSignatureResults, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;verify_webhook_signature_options&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method verify_webhook_signature&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;verify_webhook_signature_options&#39; is set
        if self.api_client.client_side_validation and (&#39;verify_webhook_signature_options&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;verify_webhook_signature_options&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `verify_webhook_signature_options` when calling `verify_webhook_signature`&#34;)  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if &#39;verify_webhook_signature_options&#39; in local_var_params:
            body_params = local_var_params[&#39;verify_webhook_signature_options&#39;]
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # HTTP header `Content-Type`
        header_params[&#39;Content-Type&#39;] = self.api_client.select_header_content_type(  # noqa: E501
            [&#39;application/json&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/verify&#39;, &#39;POST&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;VerifyWebhookSignatureResults&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)

    def wait_for_webhook_results(self, webhook_id, expected_count, timeout, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Wait for webhook results for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.wait_for_webhook_results(webhook_id, expected_count, timeout, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: ID of webhook to get results for (required)
        :param int expected_count: Expected result count (required)
        :param int timeout: Max time to wait in milliseconds (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[WebhookResultDto]
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;
        kwargs[&#39;_return_http_data_only&#39;] = True
        return self.wait_for_webhook_results_with_http_info(webhook_id, expected_count, timeout, **kwargs)  # noqa: E501

    def wait_for_webhook_results_with_http_info(self, webhook_id, expected_count, timeout, **kwargs):  # noqa: E501
        &#34;&#34;&#34;Wait for webhook results for a webhook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        &gt;&gt;&gt; thread = api.wait_for_webhook_results_with_http_info(webhook_id, expected_count, timeout, async_req=True)
        &gt;&gt;&gt; result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str webhook_id: ID of webhook to get results for (required)
        :param int expected_count: Expected result count (required)
        :param int timeout: Max time to wait in milliseconds (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[WebhookResultDto], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        &#34;&#34;&#34;

        local_var_params = locals()

        all_params = [
            &#39;webhook_id&#39;,
            &#39;expected_count&#39;,
            &#39;timeout&#39;
        ]
        all_params.extend(
            [
                &#39;async_req&#39;,
                &#39;_return_http_data_only&#39;,
                &#39;_preload_content&#39;,
                &#39;_request_timeout&#39;
            ]
        )

        for key, val in six.iteritems(local_var_params[&#39;kwargs&#39;]):
            if key not in all_params:
                raise ApiTypeError(
                    &#34;Got an unexpected keyword argument &#39;%s&#39;&#34;
                    &#34; to method wait_for_webhook_results&#34; % key
                )
            local_var_params[key] = val
        del local_var_params[&#39;kwargs&#39;]
        # verify the required parameter &#39;webhook_id&#39; is set
        if self.api_client.client_side_validation and (&#39;webhook_id&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;webhook_id&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `webhook_id` when calling `wait_for_webhook_results`&#34;)  # noqa: E501
        # verify the required parameter &#39;expected_count&#39; is set
        if self.api_client.client_side_validation and (&#39;expected_count&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;expected_count&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `expected_count` when calling `wait_for_webhook_results`&#34;)  # noqa: E501
        # verify the required parameter &#39;timeout&#39; is set
        if self.api_client.client_side_validation and (&#39;timeout&#39; not in local_var_params or  # noqa: E501
                                                        local_var_params[&#39;timeout&#39;] is None):  # noqa: E501
            raise ApiValueError(&#34;Missing the required parameter `timeout` when calling `wait_for_webhook_results`&#34;)  # noqa: E501

        if self.api_client.client_side_validation and &#39;expected_count&#39; in local_var_params and local_var_params[&#39;expected_count&#39;] &gt; 100:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `expected_count` when calling `wait_for_webhook_results`, must be a value less than or equal to `100`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;timeout&#39; in local_var_params and local_var_params[&#39;timeout&#39;] &gt; 300000:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `timeout` when calling `wait_for_webhook_results`, must be a value less than or equal to `300000`&#34;)  # noqa: E501
        if self.api_client.client_side_validation and &#39;timeout&#39; in local_var_params and local_var_params[&#39;timeout&#39;] &lt; 1000:  # noqa: E501
            raise ApiValueError(&#34;Invalid value for parameter `timeout` when calling `wait_for_webhook_results`, must be a value greater than or equal to `1000`&#34;)  # noqa: E501
        collection_formats = {}

        path_params = {}
        if &#39;webhook_id&#39; in local_var_params:
            path_params[&#39;webhookId&#39;] = local_var_params[&#39;webhook_id&#39;]  # noqa: E501

        query_params = []
        if &#39;expected_count&#39; in local_var_params and local_var_params[&#39;expected_count&#39;] is not None:  # noqa: E501
            query_params.append((&#39;expectedCount&#39;, local_var_params[&#39;expected_count&#39;]))  # noqa: E501
        if &#39;timeout&#39; in local_var_params and local_var_params[&#39;timeout&#39;] is not None:  # noqa: E501
            query_params.append((&#39;timeout&#39;, local_var_params[&#39;timeout&#39;]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params[&#39;Accept&#39;] = self.api_client.select_header_accept(
            [&#39;*/*&#39;])  # noqa: E501

        # Authentication setting
        auth_settings = [&#39;API_KEY&#39;]  # noqa: E501

        return self.api_client.call_api(
            &#39;/webhooks/{webhookId}/wait&#39;, &#39;GET&#39;,
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=&#39;list[WebhookResultDto]&#39;,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get(&#39;async_req&#39;),
            _return_http_data_only=local_var_params.get(&#39;_return_http_data_only&#39;),  # noqa: E501
            _preload_content=local_var_params.get(&#39;_preload_content&#39;, True),
            _request_timeout=local_var_params.get(&#39;_request_timeout&#39;),
            collection_formats=collection_formats)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_account_webhook"><code class="name flex">
<span>def <span class="ident">create_account_webhook</span></span>(<span>self, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a WebHook URL to an inbox
# noqa: E501</p>
<p>Get notified of account level events such as bounce and bounce recipient.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.create_account_webhook(create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param CreateWebhookOptions create_webhook_options: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_account_webhook_with_http_info"><code class="name flex">
<span>def <span class="ident">create_account_webhook_with_http_info</span></span>(<span>self, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a WebHook URL to an inbox
# noqa: E501</p>
<p>Get notified of account level events such as bounce and bounce recipient.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.create_account_webhook_with_http_info(create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param CreateWebhookOptions create_webhook_options: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook"><code class="name flex">
<span>def <span class="ident">create_webhook</span></span>(<span>self, inbox_id, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a WebHook URL to an inbox
# noqa: E501</p>
<p>Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.create_webhook(inbox_id, create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param CreateWebhookOptions create_webhook_options: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_for_phone_number"><code class="name flex">
<span>def <span class="ident">create_webhook_for_phone_number</span></span>(<span>self, phone_number_id, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a WebHook URL to a phone number
# noqa: E501</p>
<p>Get notified whenever a phone number receives an SMS via a WebHook URL.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.create_webhook_for_phone_number(phone_number_id, create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str phone_number_id: (required)
:param CreateWebhookOptions create_webhook_options: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_for_phone_number_with_http_info"><code class="name flex">
<span>def <span class="ident">create_webhook_for_phone_number_with_http_info</span></span>(<span>self, phone_number_id, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a WebHook URL to a phone number
# noqa: E501</p>
<p>Get notified whenever a phone number receives an SMS via a WebHook URL.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.create_webhook_for_phone_number_with_http_info(phone_number_id, create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str phone_number_id: (required)
:param CreateWebhookOptions create_webhook_options: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_with_http_info"><code class="name flex">
<span>def <span class="ident">create_webhook_with_http_info</span></span>(<span>self, inbox_id, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a WebHook URL to an inbox
# noqa: E501</p>
<p>Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.create_webhook_with_http_info(inbox_id, create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param CreateWebhookOptions create_webhook_options: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_all_webhooks"><code class="name flex">
<span>def <span class="ident">delete_all_webhooks</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all webhooks
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_all_webhooks(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param datetime before: before
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: None
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_all_webhooks_with_http_info"><code class="name flex">
<span>def <span class="ident">delete_all_webhooks_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all webhooks
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_all_webhooks_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param datetime before: before
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: None
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook"><code class="name flex">
<span>def <span class="ident">delete_webhook</span></span>(<span>self, inbox_id, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete and disable a Webhook for an Inbox
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_webhook(inbox_id, webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param str webhook_id: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: None
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_by_id"><code class="name flex">
<span>def <span class="ident">delete_webhook_by_id</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_webhook_by_id(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: None
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_by_id_with_http_info"><code class="name flex">
<span>def <span class="ident">delete_webhook_by_id_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_webhook_by_id_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: None
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_with_http_info"><code class="name flex">
<span>def <span class="ident">delete_webhook_with_http_info</span></span>(<span>self, inbox_id, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete and disable a Webhook for an Inbox
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.delete_webhook_with_http_info(inbox_id, webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param str webhook_id: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: None
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_account_webhooks"><code class="name flex">
<span>def <span class="ident">get_all_account_webhooks</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List account webhooks Paginated
# noqa: E501</p>
<p>List account webhooks in paginated form. Allows for page index, page size, and sort direction.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_account_webhooks(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size for paginated result list.
:param str sort: Optional createdAt sort direction ASC or DESC
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param str event_type: Optional event type
:param str health: Filter by webhook health
:param str search_filter: Optional search filter
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookProjection
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_account_webhooks_with_http_info"><code class="name flex">
<span>def <span class="ident">get_all_account_webhooks_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List account webhooks Paginated
# noqa: E501</p>
<p>List account webhooks in paginated form. Allows for page index, page size, and sort direction.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_account_webhooks_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size for paginated result list.
:param str sort: Optional createdAt sort direction ASC or DESC
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param str event_type: Optional event type
:param str health: Filter by webhook health
:param str search_filter: Optional search filter
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_endpoints"><code class="name flex">
<span>def <span class="ident">get_all_webhook_endpoints</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List Webhooks endpoints Paginated
# noqa: E501</p>
<p>List webhooks URL in paginated form. Allows for page index, page size, and sort direction.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_webhook_endpoints(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size for paginated result list.
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param str inbox_id: Filter by inboxId
:param str phone_id: Filter by phoneId
:param datetime before: Filter by created at before the given timestamp
:param str health: Filter by webhook health
:param str event_type: Optional event type
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookEndpointProjection
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_endpoints_with_http_info"><code class="name flex">
<span>def <span class="ident">get_all_webhook_endpoints_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List Webhooks endpoints Paginated
# noqa: E501</p>
<p>List webhooks URL in paginated form. Allows for page index, page size, and sort direction.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_webhook_endpoints_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size for paginated result list.
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param str inbox_id: Filter by inboxId
:param str phone_id: Filter by phoneId
:param datetime before: Filter by created at before the given timestamp
:param str health: Filter by webhook health
:param str event_type: Optional event type
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookEndpointProjection, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_results"><code class="name flex">
<span>def <span class="ident">get_all_webhook_results</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get results for all webhooks
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_webhook_results(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param bool unseen_only: Filter for unseen exceptions only
:param str result_type: Filter by result type
:param str event_name: Filter by event name
:param int min_status_code: Minimum response status
:param int max_status_code: Maximum response status
:param str inbox_id: Inbox ID
:param str sms_id: Sms ID
:param str attachment_id: Attachment ID
:param str email_id: Email ID
:param str phone_id: Phone ID
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookResult
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_results_with_http_info"><code class="name flex">
<span>def <span class="ident">get_all_webhook_results_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get results for all webhooks
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_webhook_results_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param bool unseen_only: Filter for unseen exceptions only
:param str result_type: Filter by result type
:param str event_name: Filter by event name
:param int min_status_code: Minimum response status
:param int max_status_code: Maximum response status
:param str inbox_id: Inbox ID
:param str sms_id: Sms ID
:param str attachment_id: Attachment ID
:param str email_id: Email ID
:param str phone_id: Phone ID
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookResult, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhooks"><code class="name flex">
<span>def <span class="ident">get_all_webhooks</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List Webhooks Paginated
# noqa: E501</p>
<p>List webhooks in paginated form. Allows for page index, page size, and sort direction.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_webhooks(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size for paginated result list.
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param str inbox_id: Filter by inboxId
:param str phone_id: Filter by phoneId
:param datetime before: Filter by created at before the given timestamp
:param str health: Filter by webhook health
:param str event_type: Optional event type
:param str url: Optional url endpoint filter
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookProjection
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhooks_with_http_info"><code class="name flex">
<span>def <span class="ident">get_all_webhooks_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>List Webhooks Paginated
# noqa: E501</p>
<p>List webhooks in paginated form. Allows for page index, page size, and sort direction.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_all_webhooks_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param int page: Optional page index in list pagination
:param int size: Optional page size for paginated result list.
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param str inbox_id: Filter by inboxId
:param str phone_id: Filter by phoneId
:param datetime before: Filter by created at before the given timestamp
:param str health: Filter by webhook health
:param str event_type: Optional event type
:param str url: Optional url endpoint filter
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_inbox_webhooks_paginated"><code class="name flex">
<span>def <span class="ident">get_inbox_webhooks_paginated</span></span>(<span>self, inbox_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get paginated webhooks for an Inbox
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_inbox_webhooks_paginated(inbox_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param str health: Filter by webhook health
:param str event_type: Optional event type
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookProjection
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_inbox_webhooks_paginated_with_http_info"><code class="name flex">
<span>def <span class="ident">get_inbox_webhooks_paginated_with_http_info</span></span>(<span>self, inbox_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get paginated webhooks for an Inbox
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_inbox_webhooks_paginated_with_http_info(inbox_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param str health: Filter by webhook health
:param str event_type: Optional event type
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_event"><code class="name flex">
<span>def <span class="ident">get_json_schema_for_webhook_event</span></span>(<span>self, event, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_json_schema_for_webhook_event
# noqa: E501</p>
<p>Get JSON Schema definition for webhook payload by event
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_json_schema_for_webhook_event(event, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str event: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: JSONSchemaDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_event_with_http_info"><code class="name flex">
<span>def <span class="ident">get_json_schema_for_webhook_event_with_http_info</span></span>(<span>self, event, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_json_schema_for_webhook_event
# noqa: E501</p>
<p>Get JSON Schema definition for webhook payload by event
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_json_schema_for_webhook_event_with_http_info(event, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str event: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(JSONSchemaDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_payload"><code class="name flex">
<span>def <span class="ident">get_json_schema_for_webhook_payload</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_json_schema_for_webhook_payload
# noqa: E501</p>
<p>Get JSON Schema definition for webhook payload
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_json_schema_for_webhook_payload(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: JSONSchemaDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_payload_with_http_info"><code class="name flex">
<span>def <span class="ident">get_json_schema_for_webhook_payload_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_json_schema_for_webhook_payload
# noqa: E501</p>
<p>Get JSON Schema definition for webhook payload
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_json_schema_for_webhook_payload_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(JSONSchemaDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_phone_number_webhooks_paginated"><code class="name flex">
<span>def <span class="ident">get_phone_number_webhooks_paginated</span></span>(<span>self, phone_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get paginated webhooks for a phone number
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_phone_number_webhooks_paginated(phone_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str phone_id: (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param str event_type: Optional event type
:param str search_filter: Optional search filter
:param str health: Filter by webhook health
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookProjection
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_phone_number_webhooks_paginated_with_http_info"><code class="name flex">
<span>def <span class="ident">get_phone_number_webhooks_paginated_with_http_info</span></span>(<span>self, phone_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get paginated webhooks for a phone number
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_phone_number_webhooks_paginated_with_http_info(phone_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str phone_id: (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param str event_type: Optional event type
:param str search_filter: Optional search filter
:param str health: Filter by webhook health
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookProjection, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload
# noqa: E501</p>
<p>Get test webhook payload example. Response content depends on eventName passed. Uses <code>EMAIL_RECEIVED</code> as default.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str event_name:
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: AbstractWebhookPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_bounce</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_bounce
# noqa: E501</p>
<p>Get webhook test payload for bounce
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookBouncePayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_recipient"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_bounce_recipient</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_bounce_recipient
# noqa: E501</p>
<p>Get webhook test payload for bounce recipient
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce_recipient(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookBounceRecipientPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_recipient_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_bounce_recipient_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_bounce_recipient
# noqa: E501</p>
<p>Get webhook test payload for bounce recipient
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce_recipient_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookBounceRecipientPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_bounce_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_bounce
# noqa: E501</p>
<p>Get webhook test payload for bounce
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_bounce_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookBouncePayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_delivery_status"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_delivery_status</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for delivery status event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_delivery_status(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDeliveryStatusPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_delivery_status_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_delivery_status_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for delivery status event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_delivery_status_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDeliveryStatusPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_opened"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_email_opened</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_email_opened
# noqa: E501</p>
<p>Get webhook test payload for email opened event
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_email_opened(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookEmailOpenedPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_opened_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_email_opened_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_email_opened
# noqa: E501</p>
<p>Get webhook test payload for email opened event
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_email_opened_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookEmailOpenedPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_read"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_email_read</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_email_read
# noqa: E501</p>
<p>Get webhook test payload for email opened event
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_email_read(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookEmailReadPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_read_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_email_read_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_email_read
# noqa: E501</p>
<p>Get webhook test payload for email opened event
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_email_read_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookEmailReadPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_for_webhook"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_for_webhook</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_for_webhook
# noqa: E501</p>
<p>Get example payload for webhook
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_for_webhook(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: AbstractWebhookPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_for_webhook_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_for_webhook_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload_for_webhook
# noqa: E501</p>
<p>Get example payload for webhook
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_for_webhook_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(AbstractWebhookPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_ai_transform_result"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_ai_transform_result</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new ai transform result event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_ai_transform_result(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookNewAITransformResultPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_ai_transform_result_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_ai_transform_result_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new ai transform result event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_ai_transform_result_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookNewAITransformResultPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_attachment"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_attachment</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new attachment event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_attachment(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookNewAttachmentPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_attachment_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_attachment_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new attachment event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_attachment_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookNewAttachmentPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_contact"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_contact</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new contact event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_contact(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookNewContactPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_contact_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_contact_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new contact event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_contact_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookNewContactPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_email"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_email</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new email event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_email(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookNewEmailPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_email_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_email_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new email event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_email_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookNewEmailPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_sms"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_sms</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new sms event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_sms(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookNewSmsPayload
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_sms_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_new_sms_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get webhook test payload for new sms event
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_new_sms_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookNewSmsPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_with_http_info"><code class="name flex">
<span>def <span class="ident">get_test_webhook_payload_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>get_test_webhook_payload
# noqa: E501</p>
<p>Get test webhook payload example. Response content depends on eventName passed. Uses <code>EMAIL_RECEIVED</code> as default.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_test_webhook_payload_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str event_name:
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(AbstractWebhookPayload, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook"><code class="name flex">
<span>def <span class="ident">get_webhook</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_result"><code class="name flex">
<span>def <span class="ident">get_webhook_result</span></span>(<span>self, webhook_result_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook result for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_result(webhook_result_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_result_id: Webhook Result ID (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookResultDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_result_with_http_info"><code class="name flex">
<span>def <span class="ident">get_webhook_result_with_http_info</span></span>(<span>self, webhook_result_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook result for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_result_with_http_info(webhook_result_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_result_id: Webhook Result ID (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookResultDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results"><code class="name flex">
<span>def <span class="ident">get_webhook_results</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook results for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_results(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: ID of webhook to get results for (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param bool unseen_only: Filter for unseen exceptions only
:param str result_type: Filter by result type
:param str event_name: Filter by event name
:param int min_status_code: Minimum response status
:param int max_status_code: Maximum response status
:param str inbox_id: Inbox ID
:param str sms_id: Sms ID
:param str attachment_id: Attachment ID
:param str email_id: Email ID
:param str phone_id: Phone ID
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: PageWebhookResult
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_count"><code class="name flex">
<span>def <span class="ident">get_webhook_results_count</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook results count for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_results_count(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: ID of webhook to get results for (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: CountDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_count_with_http_info"><code class="name flex">
<span>def <span class="ident">get_webhook_results_count_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook results count for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_results_count_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: ID of webhook to get results for (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(CountDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_unseen_error_count"><code class="name flex">
<span>def <span class="ident">get_webhook_results_unseen_error_count</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get count of unseen webhook results with error status
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_results_unseen_error_count(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: UnseenErrorCountDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_unseen_error_count_with_http_info"><code class="name flex">
<span>def <span class="ident">get_webhook_results_unseen_error_count_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get count of unseen webhook results with error status
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_results_unseen_error_count_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(UnseenErrorCountDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_with_http_info"><code class="name flex">
<span>def <span class="ident">get_webhook_results_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook results for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_results_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: ID of webhook to get results for (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param str search_filter: Optional search filter
:param datetime since: Filter by created at after the given timestamp
:param datetime before: Filter by created at before the given timestamp
:param bool unseen_only: Filter for unseen exceptions only
:param str result_type: Filter by result type
:param str event_name: Filter by event name
:param int min_status_code: Minimum response status
:param int max_status_code: Maximum response status
:param str inbox_id: Inbox ID
:param str sms_id: Sms ID
:param str attachment_id: Attachment ID
:param str email_id: Email ID
:param str phone_id: Phone ID
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(PageWebhookResult, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_with_http_info"><code class="name flex">
<span>def <span class="ident">get_webhook_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhook_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhooks"><code class="name flex">
<span>def <span class="ident">get_webhooks</span></span>(<span>self, inbox_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all webhooks for an Inbox
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhooks(inbox_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: list[WebhookProjection]
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhooks_with_http_info"><code class="name flex">
<span>def <span class="ident">get_webhooks_with_http_info</span></span>(<span>self, inbox_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all webhooks for an Inbox
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.get_webhooks_with_http_info(inbox_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str inbox_id: (required)
:param int page: Optional page index in list pagination
:param int size: Optional page size in list pagination
:param str sort: Optional createdAt sort direction ASC or DESC
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(list[WebhookProjection], status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_all_webhook_results"><code class="name flex">
<span>def <span class="ident">redrive_all_webhook_results</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Redrive all webhook results that have failed status
# noqa: E501</p>
<p>Allows you to resend webhook payloads for any recorded webhook result that failed to deliver the payload.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.redrive_all_webhook_results(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookRedriveAllResult
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_all_webhook_results_with_http_info"><code class="name flex">
<span>def <span class="ident">redrive_all_webhook_results_with_http_info</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Redrive all webhook results that have failed status
# noqa: E501</p>
<p>Allows you to resend webhook payloads for any recorded webhook result that failed to deliver the payload.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.redrive_all_webhook_results_with_http_info(async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookRedriveAllResult, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_webhook_result"><code class="name flex">
<span>def <span class="ident">redrive_webhook_result</span></span>(<span>self, webhook_result_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook result and try to resend the original webhook payload
# noqa: E501</p>
<p>Allows you to resend a webhook payload that was already sent. Webhooks that fail are retried automatically for 24 hours and then put in a dead letter queue. You can retry results manually using this method.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.redrive_webhook_result(webhook_result_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_result_id: Webhook Result ID (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookRedriveResult
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_webhook_result_with_http_info"><code class="name flex">
<span>def <span class="ident">redrive_webhook_result_with_http_info</span></span>(<span>self, webhook_result_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a webhook result and try to resend the original webhook payload
# noqa: E501</p>
<p>Allows you to resend a webhook payload that was already sent. Webhooks that fail are retried automatically for 24 hours and then put in a dead letter queue. You can retry results manually using this method.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.redrive_webhook_result_with_http_info(webhook_result_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_result_id: Webhook Result ID (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookRedriveResult, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.send_test_data"><code class="name flex">
<span>def <span class="ident">send_test_data</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Send webhook test data
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.send_test_data(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookTestResult
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.send_test_data_with_http_info"><code class="name flex">
<span>def <span class="ident">send_test_data_with_http_info</span></span>(<span>self, webhook_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Send webhook test data
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.send_test_data_with_http_info(webhook_id, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookTestResult, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook"><code class="name flex">
<span>def <span class="ident">update_webhook</span></span>(<span>self, webhook_id, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.update_webhook(webhook_id, create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param CreateWebhookOptions create_webhook_options: (required)
:param str inbox_id:
:param str phone_number_id:
:param bool override_auth:
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_headers"><code class="name flex">
<span>def <span class="ident">update_webhook_headers</span></span>(<span>self, webhook_id, webhook_headers, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a webhook request headers
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.update_webhook_headers(webhook_id, webhook_headers, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param WebhookHeaders webhook_headers: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: WebhookDto
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_headers_with_http_info"><code class="name flex">
<span>def <span class="ident">update_webhook_headers_with_http_info</span></span>(<span>self, webhook_id, webhook_headers, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a webhook request headers
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.update_webhook_headers_with_http_info(webhook_id, webhook_headers, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param WebhookHeaders webhook_headers: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_with_http_info"><code class="name flex">
<span>def <span class="ident">update_webhook_with_http_info</span></span>(<span>self, webhook_id, create_webhook_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.update_webhook_with_http_info(webhook_id, create_webhook_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: (required)
:param CreateWebhookOptions create_webhook_options: (required)
:param str inbox_id:
:param str phone_number_id:
:param bool override_auth:
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(WebhookDto, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.verify_webhook_signature"><code class="name flex">
<span>def <span class="ident">verify_webhook_signature</span></span>(<span>self, verify_webhook_signature_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a webhook payload signature
# noqa: E501</p>
<p>Verify a webhook payload using the messageId and signature. This allows you to be sure that MailSlurp sent the payload and not another server.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.verify_webhook_signature(verify_webhook_signature_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param VerifyWebhookSignatureOptions verify_webhook_signature_options: (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: VerifyWebhookSignatureResults
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.verify_webhook_signature_with_http_info"><code class="name flex">
<span>def <span class="ident">verify_webhook_signature_with_http_info</span></span>(<span>self, verify_webhook_signature_options, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a webhook payload signature
# noqa: E501</p>
<p>Verify a webhook payload using the messageId and signature. This allows you to be sure that MailSlurp sent the payload and not another server.
# noqa: E501
This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.verify_webhook_signature_with_http_info(verify_webhook_signature_options, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param VerifyWebhookSignatureOptions verify_webhook_signature_options: (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(VerifyWebhookSignatureResults, status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.wait_for_webhook_results"><code class="name flex">
<span>def <span class="ident">wait_for_webhook_results</span></span>(<span>self, webhook_id, expected_count, timeout, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for webhook results for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.wait_for_webhook_results(webhook_id, expected_count, timeout, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: ID of webhook to get results for (required)
:param int expected_count: Expected result count (required)
:param int timeout: Max time to wait in milliseconds (required)
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: list[WebhookResultDto]
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
<dt id="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.wait_for_webhook_results_with_http_info"><code class="name flex">
<span>def <span class="ident">wait_for_webhook_results_with_http_info</span></span>(<span>self, webhook_id, expected_count, timeout, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for webhook results for a webhook
# noqa: E501</p>
<p>This method makes a synchronous HTTP request by default. To make an
asynchronous HTTP request, please pass async_req=True</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; thread = api.wait_for_webhook_results_with_http_info(webhook_id, expected_count, timeout, async_req=True)
&gt;&gt;&gt; result = thread.get()
</code></pre>
<p>:param async_req bool: execute request asynchronously
:param str webhook_id: ID of webhook to get results for (required)
:param int expected_count: Expected result count (required)
:param int timeout: Max time to wait in milliseconds (required)
:param _return_http_data_only: response data without head status code
and headers
:param _preload_content: if False, the urllib3.HTTPResponse object will
be returned without reading/decoding response
data. Default is True.
:param _request_timeout: timeout setting for this request. If one
number provided, it will be total request
timeout. It can also be a pair (tuple) of
(connection, read) timeouts.
:return: tuple(list[WebhookResultDto], status_code(int), headers(HTTPHeaderDict))
If the method is called asynchronously,
returns the request thread.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mailslurp_client.api" href="index.html">mailslurp_client.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi">WebhookControllerApi</a></code></h4>
<ul class="">
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_account_webhook" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_account_webhook">create_account_webhook</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_account_webhook_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_account_webhook_with_http_info">create_account_webhook_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook">create_webhook</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_for_phone_number" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_for_phone_number">create_webhook_for_phone_number</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_for_phone_number_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_for_phone_number_with_http_info">create_webhook_for_phone_number_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.create_webhook_with_http_info">create_webhook_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_all_webhooks" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_all_webhooks">delete_all_webhooks</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_all_webhooks_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_all_webhooks_with_http_info">delete_all_webhooks_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook">delete_webhook</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_by_id" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_by_id">delete_webhook_by_id</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_by_id_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_by_id_with_http_info">delete_webhook_by_id_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.delete_webhook_with_http_info">delete_webhook_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_account_webhooks" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_account_webhooks">get_all_account_webhooks</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_account_webhooks_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_account_webhooks_with_http_info">get_all_account_webhooks_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_endpoints" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_endpoints">get_all_webhook_endpoints</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_endpoints_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_endpoints_with_http_info">get_all_webhook_endpoints_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_results" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_results">get_all_webhook_results</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_results_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhook_results_with_http_info">get_all_webhook_results_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhooks" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhooks">get_all_webhooks</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhooks_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_all_webhooks_with_http_info">get_all_webhooks_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_inbox_webhooks_paginated" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_inbox_webhooks_paginated">get_inbox_webhooks_paginated</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_inbox_webhooks_paginated_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_inbox_webhooks_paginated_with_http_info">get_inbox_webhooks_paginated_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_event" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_event">get_json_schema_for_webhook_event</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_event_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_event_with_http_info">get_json_schema_for_webhook_event_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_payload" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_payload">get_json_schema_for_webhook_payload</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_payload_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_json_schema_for_webhook_payload_with_http_info">get_json_schema_for_webhook_payload_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_phone_number_webhooks_paginated" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_phone_number_webhooks_paginated">get_phone_number_webhooks_paginated</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_phone_number_webhooks_paginated_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_phone_number_webhooks_paginated_with_http_info">get_phone_number_webhooks_paginated_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload">get_test_webhook_payload</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce">get_test_webhook_payload_bounce</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_recipient" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_recipient">get_test_webhook_payload_bounce_recipient</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_recipient_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_recipient_with_http_info">get_test_webhook_payload_bounce_recipient_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_bounce_with_http_info">get_test_webhook_payload_bounce_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_delivery_status" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_delivery_status">get_test_webhook_payload_delivery_status</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_delivery_status_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_delivery_status_with_http_info">get_test_webhook_payload_delivery_status_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_opened" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_opened">get_test_webhook_payload_email_opened</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_opened_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_opened_with_http_info">get_test_webhook_payload_email_opened_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_read" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_read">get_test_webhook_payload_email_read</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_read_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_email_read_with_http_info">get_test_webhook_payload_email_read_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_for_webhook" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_for_webhook">get_test_webhook_payload_for_webhook</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_for_webhook_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_for_webhook_with_http_info">get_test_webhook_payload_for_webhook_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_ai_transform_result" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_ai_transform_result">get_test_webhook_payload_new_ai_transform_result</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_ai_transform_result_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_ai_transform_result_with_http_info">get_test_webhook_payload_new_ai_transform_result_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_attachment" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_attachment">get_test_webhook_payload_new_attachment</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_attachment_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_attachment_with_http_info">get_test_webhook_payload_new_attachment_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_contact" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_contact">get_test_webhook_payload_new_contact</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_contact_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_contact_with_http_info">get_test_webhook_payload_new_contact_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_email" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_email">get_test_webhook_payload_new_email</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_email_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_email_with_http_info">get_test_webhook_payload_new_email_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_sms" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_sms">get_test_webhook_payload_new_sms</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_sms_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_new_sms_with_http_info">get_test_webhook_payload_new_sms_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_test_webhook_payload_with_http_info">get_test_webhook_payload_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook">get_webhook</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_result" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_result">get_webhook_result</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_result_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_result_with_http_info">get_webhook_result_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results">get_webhook_results</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_count" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_count">get_webhook_results_count</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_count_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_count_with_http_info">get_webhook_results_count_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_unseen_error_count" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_unseen_error_count">get_webhook_results_unseen_error_count</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_unseen_error_count_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_unseen_error_count_with_http_info">get_webhook_results_unseen_error_count_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_results_with_http_info">get_webhook_results_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhook_with_http_info">get_webhook_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhooks" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhooks">get_webhooks</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhooks_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.get_webhooks_with_http_info">get_webhooks_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_all_webhook_results" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_all_webhook_results">redrive_all_webhook_results</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_all_webhook_results_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_all_webhook_results_with_http_info">redrive_all_webhook_results_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_webhook_result" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_webhook_result">redrive_webhook_result</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_webhook_result_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.redrive_webhook_result_with_http_info">redrive_webhook_result_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.send_test_data" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.send_test_data">send_test_data</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.send_test_data_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.send_test_data_with_http_info">send_test_data_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook">update_webhook</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_headers" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_headers">update_webhook_headers</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_headers_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_headers_with_http_info">update_webhook_headers_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.update_webhook_with_http_info">update_webhook_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.verify_webhook_signature" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.verify_webhook_signature">verify_webhook_signature</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.verify_webhook_signature_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.verify_webhook_signature_with_http_info">verify_webhook_signature_with_http_info</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.wait_for_webhook_results" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.wait_for_webhook_results">wait_for_webhook_results</a></code></li>
<li><code><a title="mailslurp_client.api.webhook_controller_api.WebhookControllerApi.wait_for_webhook_results_with_http_info" href="#mailslurp_client.api.webhook_controller_api.WebhookControllerApi.wait_for_webhook_results_with_http_info">wait_for_webhook_results_with_http_info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
