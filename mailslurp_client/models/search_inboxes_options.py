# coding: utf-8

"""
    MailSlurp API

    MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository  # noqa: E501

    The version of the OpenAPI document: 6.5.2
    Contact: contact@mailslurp.dev
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from mailslurp_client.configuration import Configuration


class SearchInboxesOptions(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'page_index': 'int',
        'page_size': 'int',
        'sort_direction': 'str',
        'favourite': 'bool',
        'search': 'str',
        'tag': 'str',
        'since': 'datetime',
        'before': 'datetime',
        'inbox_type': 'str',
        'inbox_function': 'str',
        'domain_id': 'str'
    }

    attribute_map = {
        'page_index': 'pageIndex',
        'page_size': 'pageSize',
        'sort_direction': 'sortDirection',
        'favourite': 'favourite',
        'search': 'search',
        'tag': 'tag',
        'since': 'since',
        'before': 'before',
        'inbox_type': 'inboxType',
        'inbox_function': 'inboxFunction',
        'domain_id': 'domainId'
    }

    def __init__(self, page_index=None, page_size=None, sort_direction=None, favourite=None, search=None, tag=None, since=None, before=None, inbox_type=None, inbox_function=None, domain_id=None, local_vars_configuration=None):  # noqa: E501
        """SearchInboxesOptions - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._page_index = None
        self._page_size = None
        self._sort_direction = None
        self._favourite = None
        self._search = None
        self._tag = None
        self._since = None
        self._before = None
        self._inbox_type = None
        self._inbox_function = None
        self._domain_id = None
        self.discriminator = None

        self.page_index = page_index
        self.page_size = page_size
        self.sort_direction = sort_direction
        self.favourite = favourite
        self.search = search
        self.tag = tag
        self.since = since
        self.before = before
        self.inbox_type = inbox_type
        self.inbox_function = inbox_function
        self.domain_id = domain_id

    @property
    def page_index(self):
        """Gets the page_index of this SearchInboxesOptions.  # noqa: E501

        Optional page index in list pagination  # noqa: E501

        :return: The page_index of this SearchInboxesOptions.  # noqa: E501
        :rtype: int
        """
        return self._page_index

    @page_index.setter
    def page_index(self, page_index):
        """Sets the page_index of this SearchInboxesOptions.

        Optional page index in list pagination  # noqa: E501

        :param page_index: The page_index of this SearchInboxesOptions.  # noqa: E501
        :type: int
        """

        self._page_index = page_index

    @property
    def page_size(self):
        """Gets the page_size of this SearchInboxesOptions.  # noqa: E501

        Optional page size in list pagination  # noqa: E501

        :return: The page_size of this SearchInboxesOptions.  # noqa: E501
        :rtype: int
        """
        return self._page_size

    @page_size.setter
    def page_size(self, page_size):
        """Sets the page_size of this SearchInboxesOptions.

        Optional page size in list pagination  # noqa: E501

        :param page_size: The page_size of this SearchInboxesOptions.  # noqa: E501
        :type: int
        """

        self._page_size = page_size

    @property
    def sort_direction(self):
        """Gets the sort_direction of this SearchInboxesOptions.  # noqa: E501

        Optional createdAt sort direction ASC or DESC  # noqa: E501

        :return: The sort_direction of this SearchInboxesOptions.  # noqa: E501
        :rtype: str
        """
        return self._sort_direction

    @sort_direction.setter
    def sort_direction(self, sort_direction):
        """Sets the sort_direction of this SearchInboxesOptions.

        Optional createdAt sort direction ASC or DESC  # noqa: E501

        :param sort_direction: The sort_direction of this SearchInboxesOptions.  # noqa: E501
        :type: str
        """
        allowed_values = [None,"ASC", "DESC"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and sort_direction not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `sort_direction` ({0}), must be one of {1}"  # noqa: E501
                .format(sort_direction, allowed_values)
            )

        self._sort_direction = sort_direction

    @property
    def favourite(self):
        """Gets the favourite of this SearchInboxesOptions.  # noqa: E501

        Optionally filter results for favourites only  # noqa: E501

        :return: The favourite of this SearchInboxesOptions.  # noqa: E501
        :rtype: bool
        """
        return self._favourite

    @favourite.setter
    def favourite(self, favourite):
        """Sets the favourite of this SearchInboxesOptions.

        Optionally filter results for favourites only  # noqa: E501

        :param favourite: The favourite of this SearchInboxesOptions.  # noqa: E501
        :type: bool
        """

        self._favourite = favourite

    @property
    def search(self):
        """Gets the search of this SearchInboxesOptions.  # noqa: E501

        Optionally filter by search words partial matching ID, tags, name, and email address  # noqa: E501

        :return: The search of this SearchInboxesOptions.  # noqa: E501
        :rtype: str
        """
        return self._search

    @search.setter
    def search(self, search):
        """Sets the search of this SearchInboxesOptions.

        Optionally filter by search words partial matching ID, tags, name, and email address  # noqa: E501

        :param search: The search of this SearchInboxesOptions.  # noqa: E501
        :type: str
        """

        self._search = search

    @property
    def tag(self):
        """Gets the tag of this SearchInboxesOptions.  # noqa: E501

        Optionally filter by tags. Will return inboxes that include given tags  # noqa: E501

        :return: The tag of this SearchInboxesOptions.  # noqa: E501
        :rtype: str
        """
        return self._tag

    @tag.setter
    def tag(self, tag):
        """Sets the tag of this SearchInboxesOptions.

        Optionally filter by tags. Will return inboxes that include given tags  # noqa: E501

        :param tag: The tag of this SearchInboxesOptions.  # noqa: E501
        :type: str
        """

        self._tag = tag

    @property
    def since(self):
        """Gets the since of this SearchInboxesOptions.  # noqa: E501

        Optional filter by created after given date time  # noqa: E501

        :return: The since of this SearchInboxesOptions.  # noqa: E501
        :rtype: datetime
        """
        return self._since

    @since.setter
    def since(self, since):
        """Sets the since of this SearchInboxesOptions.

        Optional filter by created after given date time  # noqa: E501

        :param since: The since of this SearchInboxesOptions.  # noqa: E501
        :type: datetime
        """

        self._since = since

    @property
    def before(self):
        """Gets the before of this SearchInboxesOptions.  # noqa: E501

        Optional filter by created before given date time  # noqa: E501

        :return: The before of this SearchInboxesOptions.  # noqa: E501
        :rtype: datetime
        """
        return self._before

    @before.setter
    def before(self, before):
        """Sets the before of this SearchInboxesOptions.

        Optional filter by created before given date time  # noqa: E501

        :param before: The before of this SearchInboxesOptions.  # noqa: E501
        :type: datetime
        """

        self._before = before

    @property
    def inbox_type(self):
        """Gets the inbox_type of this SearchInboxesOptions.  # noqa: E501

        Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).  # noqa: E501

        :return: The inbox_type of this SearchInboxesOptions.  # noqa: E501
        :rtype: str
        """
        return self._inbox_type

    @inbox_type.setter
    def inbox_type(self, inbox_type):
        """Sets the inbox_type of this SearchInboxesOptions.

        Type of inbox. HTTP inboxes are faster and better for most cases. SMTP inboxes are more suited for public facing inbound messages (but cannot send).  # noqa: E501

        :param inbox_type: The inbox_type of this SearchInboxesOptions.  # noqa: E501
        :type: str
        """
        allowed_values = [None,"HTTP_INBOX", "SMTP_INBOX"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and inbox_type not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `inbox_type` ({0}), must be one of {1}"  # noqa: E501
                .format(inbox_type, allowed_values)
            )

        self._inbox_type = inbox_type

    @property
    def inbox_function(self):
        """Gets the inbox_function of this SearchInboxesOptions.  # noqa: E501

        Optional filter by inbox function  # noqa: E501

        :return: The inbox_function of this SearchInboxesOptions.  # noqa: E501
        :rtype: str
        """
        return self._inbox_function

    @inbox_function.setter
    def inbox_function(self, inbox_function):
        """Sets the inbox_function of this SearchInboxesOptions.

        Optional filter by inbox function  # noqa: E501

        :param inbox_function: The inbox_function of this SearchInboxesOptions.  # noqa: E501
        :type: str
        """
        allowed_values = [None,"ALIAS", "THREAD", "CATCH_ALL", "CONNECTOR"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and inbox_function not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `inbox_function` ({0}), must be one of {1}"  # noqa: E501
                .format(inbox_function, allowed_values)
            )

        self._inbox_function = inbox_function

    @property
    def domain_id(self):
        """Gets the domain_id of this SearchInboxesOptions.  # noqa: E501

        Optional domain ID filter  # noqa: E501

        :return: The domain_id of this SearchInboxesOptions.  # noqa: E501
        :rtype: str
        """
        return self._domain_id

    @domain_id.setter
    def domain_id(self, domain_id):
        """Sets the domain_id of this SearchInboxesOptions.

        Optional domain ID filter  # noqa: E501

        :param domain_id: The domain_id of this SearchInboxesOptions.  # noqa: E501
        :type: str
        """

        self._domain_id = domain_id

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SearchInboxesOptions):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, SearchInboxesOptions):
            return True

        return self.to_dict() != other.to_dict()
